// Simonoids - Arduino-based 'Simon' game in an Altoids can
//
// Copyright (c) 2012 John Graham-Cumming

#include <EEPROM.h>

// There are four buttons and four LEDs.  Each LED has a port and each button
// a port.  The buttons have the internal pull-up resistor enabled to save having
// four resistors for external pull up.

int RED = 0;
int GRN = 1;
int BLU = 2;
int YLW = 3;

int LEDS = 2;
int BUTS = LEDS + 4;

// Software fix of hardware problem :-)  The correct sequence to make the buttons
// light up clockwise

int clockwise[4] = { RED, BLU, YLW, GRN };

// There's also a piezo speaker on a port

int SPEAKER = 10;

// These are the delay times in us require to produce the four tones.  The four
// tones are as follows:
//
// RED G 195.998 Hz 5.102ms
// BLU C 261.626 Hz 3.822ms
// GRN E 329.628 Hz 3.034ms
// YLW G 391.995 Hz 2.551ms
//
//                  RED   GRN   BLU   YLW
int tone_us[4] = { 5102, 3034, 3822, 2551 };

void setup() {
  
  // Set up all the appropriate modes for the LEDs, buttons and speaker.  The
  // LEDs are connected with a suitable current limiting resistor, the buttons
  // are pulled up using the internal resistors. 
  
  for ( int i = RED; i <= YLW; ++i ) {
    pinMode(LEDS + i, OUTPUT);
  }
  
  for ( int i = RED; i <= YLW; ++i ) {
    pinMode(BUTS + i, INPUT);
    digitalWrite(BUTS + i, HIGH);
  }
  
  pinMode(SPEAKER, OUTPUT);
  analogWrite(SPEAKER, 0);
 
  // Set the random number generator from a seed generated by reading from a 
  // floating analog pin or two
  
  long seed = micros();
  for ( int i = 0; i < 1000; ++i ) {
    seed += analogRead(0);
    seed += analogRead(1);
    seed += micros();
  }
  
  // Use EEPROM locations to store a value from the random number generator so that from 
  // switch on to switch on the seed will change even if the above loop always gave the same
  // value
  
  for ( int i = 0; i < 4; ++i ) {
    seed += (long)EEPROM.read(i);
  }
  
  randomSeed(seed); 

  for ( int i = 0; i < 4; ++i ) {
    EEPROM.write(i, random(0,255));
  }
  
  start();
  new_game();
}

// The possible game lengths which are selected using the colored buttons as below
//
//               RED GRN BLU YLW
int games[4] = {   8, 20, 14, 31 };

// The number of button presses in a complete game.  The plays array contains the button
// sequence for this round. See new_game() for how these are set.  pos is the current
// position reached in this round.
int game;
int plays[31];
int pos;

void loop() {
  
  // Game play works as follows: first the sequence up to and including pos is played
  // for the user.  Then the user has a chance to repeat the sequence.  If they get it
  // right then either the next pos is selected or they've won.  If they get it wrong then
  // fail and start a new_game().
  
  for ( int i = 0; i <= pos; ++i ) {
    play(plays[i]);
  }
  
  for ( int i = 0; i <= pos; ++i ) {
    int but = wait_button();
    wait_release(but);

    if ( but != plays[i] ) {
      fail(plays[i]);
      restart();
      return;
    }
  }

  pos += 1;
  
  if ( pos == game ) {
    win();
    restart();
  } else {
     delay(500);
  }
}

// play: lights a single button and plays the appropriate button tune for it
// and waits and then shuts it off.
void play(int b) {
  led(b, 1);
  tone(b, 250);
  led(b, 0);
  delay(250);
}

// fail: the user has made a mistake.  Tell them and flash the appropriate button.
void fail(int b) {
  light_leds();
  tone(-1, 2000);
  clear_leds();
  
  delay(500);
  led(b, 1);
  tone(b, 250);
  led(b, 0);
}

// win: the user has succeeded
void win() {
  
  // Rotate the LEDs around to indicate that the player has won

  for ( int j = 0; j < 5; ++j ) {  
    for ( int i = 0; i < 4; ++i ) {
      int b = clockwise[i];
      led(b, 1);
      tone(b, 250);
      led(b, 0);
    }
  }
  
  light_leds();  
  delay(500);
  clear_leds();
}

// new_game: thinks of a new sequence of lights to flash and sets up a new game
// ready for play.  There are four possible sequence lengths (based on the lengths
// in the original Simon game): 8, 14, 20 and 31.  These are selected by clicking 
// the RED, BLU, GRN and YLW buttons in that order.
void new_game() {  
  
  // Loop around waiting for a button to be pressed.  If nothing has happened for
  // a while then play the start() fanfare again to warn people that the game has
  // been left on.
  
  int but = wait_button();
  wait_release(but);
  
  game = games[but];
  
  for ( int i = 0; i < game; ++i ) {
    plays[i] = random(RED, YLW+1);
  }
  
  pos = 0;
  
  delay(500);
  light_leds();
  delay(500);
  clear_leds();
  delay(500);
}

// wait_button: wait for a button to be pressed and return its button number.  The
// button will be illuminated when this function returns.
int wait_button() {
  unsigned long now = millis();
  
  while (1) {
    for ( int i = RED; i <= YLW; ++i ) {
      if ( button(i) == 1) {
        delay(50);
        if ( button(i) == 1 ) {
          led(i, 1);
          return i;
        }
      }
    }
    
    if ( millis() > ( now + 30000 ) ) {
      start();
      clear_leds();
      now = millis();
    }
  }
}

// wait_release: wait for a button to be released.  Clears the button LED when it is
// finally released.
void wait_release(int b) {
  int delay_us = tone_us[b];

  while (1) {
    while ( button(b) == 1 ) {
      digitalWrite(SPEAKER, HIGH);
      delayMicroseconds(delay_us/2);
      digitalWrite(SPEAKER, LOW);
      delayMicroseconds(delay_us/2);
    }
    delay(50);
    if ( button(b) == 0 ) {
      break;
    }
  }
  
  led(b, 0);
}

// clear_leds: make sure that all the LEDs are turned off
void clear_leds() {
  for ( int i = RED; i <= YLW; ++i ) {
    led(i, 0);
  }
}

// light_leds: turn all the LEDs on
void light_leds() {
  for ( int i = RED; i <= YLW; ++i ) {
    led(i, 1);
  }
}

// start: small function called once the hardware is set up that plays a sort of
// fanfare so that people know the game is ready.
void start() {
  for ( int i = 0; i < 4; ++i ) {
    int b = clockwise[i];
    led(b, 1);
    tone(b, 200);
    led(b, 0);
  }
  
  light_leds();
  delay(500);
  clear_leds();
}

// restart: start a new game after a game has just been played
void restart() {
  delay(2000);
  start();
  new_game();
}

// led: Set the state of LED l to on or off (1 == on, 0 == off)
void led(int l, int on) {
  digitalWrite(LEDS + l, on?HIGH:LOW);
}

// button: read the state of button b.  Returns 1 if pressed, 0 otherwise
int button(int b) {
  return (digitalRead(BUTS + b)==HIGH)?0:1; 
}

// tone: play the tone appropriate for a button, or play a buzz sound used
// for a failure (send button -1)
void tone(int b, int ms) {
  int delay_us;
  if ( b == -1 ) {
    delay_us = 7644;  // C below middle C
  } else {
    delay_us = tone_us[b];
  }
  
  long total_us = (long)ms * 1000;
  while ( total_us > 0 ) {
    digitalWrite(SPEAKER, HIGH);
    delayMicroseconds(delay_us/2);
    digitalWrite(SPEAKER, LOW);
    delayMicroseconds(delay_us/2);
    total_us -= delay_us;    
  }
}

